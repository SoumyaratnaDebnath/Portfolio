<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Soumyaratna Debnath">
<meta name="dcterms.date" content="2024-04-21">
<meta name="description" content="Inspired from Eternal Vertex Cover problem, The Rail Guardians is a two-player game where the players alternate between defending and attacking positions in a dynamic, strategic showdown.">

<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../badge-sd-fill.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../education.html" rel="" target="">
 <span class="menu-text">Education</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../experience.html" rel="" target="">
 <span class="menu-text">Experience</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html" rel="" target="">
 <span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blogs.html" rel="" target="">
 <span class="menu-text">Blogs</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../documents/Resume-Soumyaratna.pdf" rel="" target="">
 <span class="menu-text">Resume</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Rail Guardians</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Game Theory</div>
    <div class="quarto-category">Graph Theory</div>
    <div class="quarto-category">Game Development</div>
  </div>
  </div>

<div>
  <div class="description">
    Inspired from Eternal Vertex Cover problem, The Rail Guardians is a two-player game where the players alternate between defending and attacking positions in a dynamic, strategic showdown.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Soumyaratna Debnath </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 21, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p><a href="https://github.com/SoumyaratnaDebnath/The-Rail-Guardians" style="text-decoration: none;"> <i class="bi bi-github"></i> <span class="about-link-text">GitHub</span> </a>   <a href="https://soumyaratnadebnath.github.io/The-Rail-Guardians/" style="text-decoration: none;"> <i class="bi bi-controller"></i> <span class="about-link-text">Play the Game</span> </a></p>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">Introduction</h3>
<p>A <strong>vertex cover</strong> [1] is a set of vertices within a graph such that every edge in the graph has at least one endpoint in the vertex cover set. Mathematically, for a graph G(V, E), as set S ⊆ V(G) is said to be a vertex cover of G if for any (u, v) ∈ E(G) either u ∈ S or v ∈ S. The size of the smallest vertex cover of graph G is called the <strong>minimum vertex cover</strong> of G, denoted by <strong><em>mvc(G)</em></strong>. Figure 1 shows a simple cycle graph G’ of 4 vertices with mvc(G’) = 2.</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.004.png" class="img-fluid"></p>
<p><em>Figure 1 – A cycle graph G’ with 4 vertices; mvc (G’) = 2.</em></p>
<p>The dynamic variant of the vertex cover problem involves a game scenario where guards are positioned on certain vertices of a graph by the defender [2]. The attacker plays by selecting and attacking an edge, challenging the defender to respond by moving the guards along the graph’s edges. The defender’s goal is to ensure that at least one guard moves along the attacked edge in response to each attack. If the defender is unable to make such a move,</p>
<p>the attacker wins. Conversely, if the defender can successfully defend against an infinite sequence of attacks, the defender wins. Figure 2 describes the possible scenarios of the gameplay. If both ends of the attacked edge are unguarded then the attacker wins. If only one end of the attacked edge is guarded, then that guard must move across the attacked edge to counter the attack. If both ends of the attacked edge are guarded, then the two guards swap their positions.</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.005.jpeg" class="img-fluid"></p>
<p><em>Figure 2 - Possible scenarios of the gameplay. Red vertices are guarded, and greens are unguarded.</em></p>
<p>The minimum number of guards required for the defender to maintain a winning strategy is called the <strong>eternal vertex cover number</strong> of the graph, denoted as <strong><em>evc(G)</em></strong>.</p>
<p>The walkthrough of the eternal vertex for a cyclic graph with 4 vertex is given in Figure 3.</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.006.jpeg" class="img-fluid"></p>
<p><em>Figure 3 - Walkthrough of Eternal vertex cover. Red vertices are guarded, and greens are unguarded.</em></p>
</section>
<section id="background" class="level3">
<h3 class="anchored" data-anchor-id="background">Background</h3>
<p>The problem of Eternal Vertex Cover was introduced by Klostermeyer and Mynhardt in 2009 [2]. Klostermeyer et al.&nbsp;concluded that <em>mvc(G) ≤ evc(G) ≤ 2mvc(G)</em>. Following that many works have studied EVC in greater detail. Calamoneri et al.&nbsp;[3] studies the Eternal Vertex Cover problem on infinite and finite grid graphs, offering insights into the transition between these two graph types. Babu, et al.&nbsp;[4] investigates graphs with a minimal Eternal Vertex Cover number, focusing on those with unique properties that allow for a smaller number of guards. Fomin et al.&nbsp;explored the complexity of the problem and concluded that the problem is NP-Hard, yet has a polynomial time 2-approximation algorithm [5]. Babu et al.&nbsp;also explored the graphs whose eternal vertex cover number and vertex cover number coincide [4]. Babu et al.&nbsp;also concluded that the problem does not admit a polynomial compression even on bipartite graphs of diameter six [6].</p>
</section>
<section id="the-rail-guardians" class="level3">
<h3 class="anchored" data-anchor-id="the-rail-guardians">The Rail Guardians</h3>
<p><em>The Rail Guardians</em> is my interpretation of the Eternal Vertex Cover Problem, reimagined as a captivating two-player web-based game with an interesting storyline and across three different variants (modes).</p>
<p><strong>The Storyline</strong> <strong>–</strong> The game is set in an imaginary world and the storyline goes as follows.</p>
<p><em>You’re in charge of keeping the railway tracks safe in a world filled with</em> <em>protests and demands for change. As the head of railway operations, your mission is to prevent accidents by making sure every piece of track is watched over by your team of dedicated track builders. Protesters might target and destroy unwatched sections of the railway to make their voices heard. Your job is to strategically place your builders so that no track is left unguarded. Ready to take on the challenge? Keep your eyes sharp and your mind sharper to keep the railways and your passengers safe.</em></p>
<p><strong>Mode 1 – Rail Guardians reporting Sir!</strong></p>
<p>This mode is the implementation of generic eternal vertex cover [2]. The game starts with the defender placing the builders on the graph. The attacker then tries to attack the tracks. With</p>
<p>N builders on boards, in defender’s next move, defender can update the position of the builders (excluding the one builder who had to walk across the attacked track). Each builder</p>
<p>can at most move across one track. The attacker wins if an unguarded track is attacked. Defender wins if all tracks are guarded till the selected number of rounds.</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.008.jpeg" class="img-fluid"></p>
<p><em>Figure 4 - Mode 1 home.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.009.jpeg" class="img-fluid"></p>
<p><em>Figure 5 - Mode 1 start menu.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.010.jpeg" class="img-fluid"></p>
<p><em>Figure 6 - Mode 1 gameplay.</em></p>
<p><strong>Mode 2 – The Challenge has Escalated!</strong></p>
<p><em>Storyline - Protestors have managed to steal the railway track map, making it</em> <em>impossible for you to monitor the tracks through your usual systems. Now, the only way to keep track of the network is through reports from your field builders. In this level, you’ll need to rely on your memory and strategic planning skills. Your builders will relay information about sections of the track as they survey them, but once communication ends, you won’t have a visual map to refer back to. You must memorize and visualize the track layout based on their reports. Can you keep the railways safe using only the details you hold in your mind? Let’s find out in this thrilling new challenge!</em></p>
<p>In this mode, the game starts with the defender placing the builders on the graph. But there is a catch! The graph is not visible to the defender altogether. Rather only a part of the graph is visible to the defender at an instance. Hovering over each station gives the defender intel of the tracks connected to that station. Once the guards are placed, the gameplay continues as the previous mode.</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.011.jpeg" class="img-fluid"></p>
<p><em>Figure 7 - Mode 2 home</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.012.jpeg" class="img-fluid"></p>
<p><em>Figure 8 - Mode 2 start menu.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.013.jpeg" class="img-fluid"></p>
<p><em>Figure 9 - Mode 2 gameplay: hover action.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.014.jpeg" class="img-fluid"></p>
<p><em>Figure 10 - Mode 2 gameplay: attacker’s move.</em></p>
<p><strong>Mode 3 – The Final Attempt!</strong></p>
<p><em>Storyline - As the day winds down, both your track builders and the protestors</em> <em>are feeling the wear of their efforts. Tonight, the energy levels of your builders are limited, and they can only shift their monitoring positions for limited times. Similarly, the protestors have just enough energy as the builders for final attempts to disrupt the railway tracks. Your task is to strategically redeploy your builders to the most critical sections of the track for these last few hours. Use your builders’ remaining energy efficiently and outsmart the protestors’ final moves. Remember, this is a crucial moment; if you can keep the tracks safe tonight, there’s a good chance the government will meet the protestors’ demands by tomorrow, and normal operations can resume.</em></p>
<p>In this mode, the game starts with the defender placing the builders on the graph. But now, each builder has a certain amount of energy associated with it. Whenever a builder is moved by the defender, the energy of the builder decreases by 1. When the defender passes the turn to the attacker without making a move, the builder with the max energy loses 1 energy. The game ends when the energy of any builder reaches 0, or when the attacker attacks an unguarded track. The number of rounds the defender has guarded the track is the score of the defender. The aim is to get the highest score!</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.015.jpeg" class="img-fluid"></p>
<p><em>Figure 11 - Mode 3 home.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.016.jpeg" class="img-fluid"></p>
<p><em>Figure 12 - Mode 3 start menu.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.017.jpeg" class="img-fluid"></p>
<p><em>Figure 13 - Mode 3 gameplay.</em></p>
<p><strong>Dark Mode –</strong> The game features a dark mode to accommodate users who prefer a darker theme or play in low-light environments, reducing eye strain and providing a visually comfortable experience.</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.018.jpeg" class="img-fluid"></p>
<p><em>Figure 14 - Dark mode: home.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.019.jpeg" class="img-fluid"></p>
<p><em>Figure 15 - Dark mode: start menu.</em></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.020.jpeg" class="img-fluid"></p>
<p><em>Figure 16 - Dark mode: gameplay.</em></p>
<p><strong>Implementation –</strong> The implementation uses only HTML, CSS, and vanilla JavaScript without any third-party libraries. This minimalistic approach ensures a lightweight experience.</p>
</section>
<section id="analysis-of-max-score-for-energy-aware-evc-on-linear-paths" class="level3">
<h3 class="anchored" data-anchor-id="analysis-of-max-score-for-energy-aware-evc-on-linear-paths">Analysis of Max Score for Energy Aware EVC on Linear Paths</h3>
<p>In Energy Aware Eternal Vertex Cover (Mode 3 of the game), each guard has a limited amount</p>
<p>of energy, and the game ends if any guard’s energy reaches zero. Analyzing the maximum achievable score in this mode can help by revealing optimal guard movement strategies and energy management. By understanding the maximum score, players can develop tactics</p>
<p>that balance defense and energy conservation, thereby extending gameplay and achieving better results. This analysis can guide game design improvements, leading to a more engaging and challenging experience for players.</p>
<p>I have performed some basic analysis of the maximum score achievable by the defender where each guard has energy K, and K is numerically big!</p>
<p>Table 1 summarizes my analysis across paths of size 2 to 5, and different number of builders.</p>
<p><em>Table 1 - Analysis of Max Score for Energy Aware Eternal Vertex Cover on Linear Graphs / Paths</em></p>
<table class="table">
<thead>
<tr class="header">
<th><strong>Stations</strong></th>
<th><strong>Builders</strong></th>
<th><strong>Energy</strong></th>
<th><strong>Max Score</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>1</td>
<td>K</td>
<td><strong>K</strong></td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>K</td>
<td><strong>1</strong></td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
<td>K</td>
<td><strong>2K – 1</strong></td>
</tr>
<tr class="even">
<td>4</td>
<td>1</td>
<td>K</td>
<td><strong>0</strong></td>
</tr>
<tr class="odd">
<td>4</td>
<td>2</td>
<td>K</td>
<td><strong>2</strong></td>
</tr>
<tr class="even">
<td>4</td>
<td>3</td>
<td>K</td>
<td><strong>3K – 2</strong></td>
</tr>
<tr class="odd">
<td>5</td>
<td>1</td>
<td>K</td>
<td><strong>0</strong></td>
</tr>
<tr class="even">
<td>5</td>
<td>2</td>
<td>K</td>
<td><strong>1</strong></td>
</tr>
<tr class="odd">
<td>5</td>
<td>3</td>
<td>K</td>
<td><strong>3</strong></td>
</tr>
<tr class="even">
<td>5</td>
<td>4</td>
<td>K</td>
<td><strong>4K – 3</strong></td>
</tr>
</tbody>
</table>
<p>Analysis of optimum placement of builders to achieve the maximum score</p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.021.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.022.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.023.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.024.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.025.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.026.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.027.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.028.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.029.png" class="img-fluid"></p>
<p><img src="Aspose.Words.7a64c32a-876e-47ab-8de3-dab2df2c255e.030.png" class="img-fluid"></p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>In conclusion, my final course project centered on implementing the Eternal Vertex Cover as a two-player UI based game through a process of planning, coding, and debugging. Alongside the core implementation, I also integrated additional modes and features to make the game engaging and enhance the gameplay. The project was a great experience for me, and the lessons I learned while building it helped me understand the intricacies of game development, problem-solving, and user interface design.</p>
<p>I am deeply encouraged to work more on the problem statement. Also, I look forward to use meta-heuristics and genetic algorithms to compute the maximum achievable score in Energy Aware Eternal Vertex Cover.</p>
</section>
<section id="acknowledgements" class="level3">
<h3 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h3>
<p>I express my gratitude to Prof.&nbsp;Neeldhara Misra, Prof.&nbsp;Jyothi Krishnan, and Saraswati Girish Nanoti for their constant guidance and encouragement. I thank Sakshi for helping me with the beautiful storyline.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<ol type="1">
<li>“Vertex cover,” Wikipedia. Mar.&nbsp;01, 2024. Accessed: Apr.&nbsp;26, 2024. [Online]. Available: https://en.wikipedia.org/w/index.php?title=Vertex_cover&amp;oldid=1211245782</li>
<li>W. F. Klostermeyer and C. M. Mynhardt, “Edge protection in graphs”.</li>
<li>T. Calamoneri and F. Corò, “(Eternal) Vertex Cover Number of Infinite and Finite Grid Graphs.” arXiv, Sep.&nbsp;12, 2022. doi: 10.48550/arXiv.2209.05102.</li>
<li>J. Babu, L. S. Chandran, M. Francis, V. Prabhakaran, D. Rajendraprasad, and J. N. Warrier, “On Graphs with Minimal Eternal Vertex Cover Number,” in Algorithms and Discrete Applied Mathematics, S. P. Pal and A. Vijayakumar, Eds., Cham: Springer International Publishing, 2019, pp.&nbsp;263–273. doi: 10.1007/978-3-030-11509-8_22.</li>
<li>F. V. Fomin, S. Gaspers, P. A. Golovach, D. Kratsch, and S. Saurabh, “Parameterized algorithm for eternal vertex cover,” Inf. Process. Lett., vol.&nbsp;110, no. 16, pp.&nbsp;702–706, Jul.&nbsp;2010, doi: 10.1016/j.ipl.2010.05.029.</li>
<li>J. Babu, N. Misra, and S. G. Nanoti, “Eternal Vertex Cover on Bipartite Graphs,” in Computer Science – Theory and Applications, A. S. Kulikov and S. Raskhodnikova, Eds., Cham: Springer International Publishing, 2022, pp.&nbsp;64–76. doi: 10.1007/978-3-031- 09574-0_5.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>